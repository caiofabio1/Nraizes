
import os
import requests
from requests.auth import HTTPBasicAuth
from getpass import getpass
import datetime

# Configuration
BASE_URL = "https://api.correios.com.br/token/v1/autentica"

def generate_token(user, password, contract_number=None, post_card=None):
    """
    Generates a token for Correios API.
    
    Args:
        user (str): Meu Correios user.
        password (str): Access code.
        contract_number (str, optional): Contract number if using /autentica/contrato.
        post_card (str, optional): Post card number if using /autentica/cartaopostagem.
    """
    
    url = BASE_URL
    
    if contract_number:
        url = f"{BASE_URL}/contrato"
        # Determine if payload is needed or just auth + url param?
        # Docs say: "Gera um token... com autorização pelo número de contrato"
        # Usually extra params go in body or query. Given schemas, likely body.
        # But for now, let's stick to the simple /autentica which authorizes the user directly.
        # If the user specifically needs contract auth, we might need to adjust.
        # Simple auth is safest start.
        print(f"URL alterada para: {url} (Contrato: {contract_number})")
        # TODO: Implement contract payload if necessary.
        # Based on schema 'ContratoInput', likely data={"numero": contract_number}
        data = {"numero": contract_number}
    elif post_card:
        url = f"{BASE_URL}/cartaopostagem"
        print(f"URL alterada para: {url} (Cartão: {post_card})")
        data = {"numero": post_card}
    else:
        # Standard user auth
        data = None

    print(f"Solicitando token para usuário: {user} em {url}...")
    
    try:
        if data:
             response = requests.post(url, auth=HTTPBasicAuth(user, password), json=data)
        else:
            response = requests.post(url, auth=HTTPBasicAuth(user, password))
            
        response.raise_for_status()
        
        token_data = response.json()
        
        # Display results
        print("\n✅ Token gerado com sucesso!")
        print("-" * 50)
        print(f"Token: {token_data.get('token')}")
        
        # Handle different expiration formats if any, but docs say 'expiraEm'
        expires_in = token_data.get('expiraEm') or token_data.get('expiration')
        print(f"Expira em: {expires_in}")
        
        if 'api' in token_data:
             print(f"API ID: {token_data['api']}")
             
        # Check permissions/groups if available
        if 'grupos' in token_data:
            print(f"Grupos: {len(token_data['grupos'])}")
            
        print("-" * 50)
        
        # Save to file option
        save = input("\nDeseja salvar este token em .credentials/correios_api_tokens.env? (S/n): ").lower()
        if save != 'n':
             save_token_to_file(token_data)
        
        return token_data

    except requests.exceptions.HTTPError as e:
        print(f"\n❌ Erro na requisição: {e}")
        if e.response is not None:
            print(f"Status: {e.response.status_code}")
            try:
                print(f"Detalhes: {e.response.json()}")
            except:
                print(f"Corpo (Raw): {e.response.content.decode('utf-8', errors='replace')}")
    except Exception as e:
        import traceback
        traceback.print_exc()
        print(f"\n❌ Ocorreu um erro inesperado: {e}")

def save_token_to_file(token_data):
    """Saves the token to a .env file."""
    try:
        # Define path
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        cred_dir = os.path.join(base_dir, '.credentials')
        os.makedirs(cred_dir, exist_ok=True)
        env_path = os.path.join(cred_dir, 'correios_api_tokens.env')
        
        token = token_data.get('token')
        expiration = token_data.get('expiraEm') or token_data.get('expiration')
        
        # Read existing content to preserve other vars if any (or just overwrite if simple)
        # For simplicity and to avoid stale data, we'll write fresh or update keys.
        
        new_lines = [
            f"# Generated by generate_correios_token.py at {datetime.datetime.now()}",
            f"CORREIOS_ACCESS_TOKEN={token}",
            f"CORREIOS_TOKEN_EXPIRATION={expiration}"
        ]
        
        # If file exists, we might want to check for other keys, but for now let's just create/overwrite
        # to ensure it's clean. If the user maintains this file manually, we should append/replace.
        # Let's try to read and replace if it exists.
        
        final_content = ""
        current_vars = {}
        
        if os.path.exists(env_path):
            with open(env_path, 'r') as f:
                lines = f.readlines()
                for line in lines:
                    if '=' in line and not line.strip().startswith('#'):
                        key, val = line.strip().split('=', 1)
                        current_vars[key] = val
        
        # Update our specific keys
        current_vars['CORREIOS_ACCESS_TOKEN'] = token
        current_vars['CORREIOS_TOKEN_EXPIRATION'] = expiration
        
        with open(env_path, 'w') as f:
            f.write(f"# Updated at {datetime.datetime.now()}\n")
            for k, v in current_vars.items():
                f.write(f"{k}={v}\n")
                
        print(f"✅ Token salvo em: {env_path}")
        
    except Exception as e:
        print(f"❌ Erro ao salvar token: {e}")

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Gerador de Token Correios')
    parser.add_argument('--user', help='Usuário (Meu Correios)')
    parser.add_argument('--password', help='Código de Acesso')
    parser.add_argument('--contract', help='Número do contrato (opcional)')
    parser.add_argument('--card', help='Número do cartão de postagem (opcional)')
    parser.add_argument('--save', action='store_true', help='Salvar token automaticamente no .env')
    
    args = parser.parse_args()
    
    print("=== Gerador de Token Correios ===")
    
    # 1. Determine User/Pass
    if args.user and args.password:
        user = args.user
        password = args.password
        print(f"Usando credenciais da linha de comando (Usuário: {user})")
    else:
        # Try env
        env_user = os.getenv("CORREIOS_USER")
        env_pass = os.getenv("CORREIOS_PASSWORD")
        
        if env_user and env_pass:
            print(f"Credenciais encontradas nas variáveis de ambiente (Usuário: {env_user})")
            use_env = input("Deseja usar estas credenciais? (S/n): ").lower()
            if use_env != 'n':
                user = env_user
                password = env_pass
            else:
                user = input("Usuário (Meu Correios): ")
                password = getpass("Código de Acesso (Senha): ")
        else:
            user = input("Usuário (Meu Correios): ")
            password = getpass("Código de Acesso (Senha): ")

    # 2. Determine Mode
    contract = args.contract
    card = args.card
    
    if not contract and not card:
        # Only ask if not provided via CLI
        # Check if we are running interactively? 
        # For mixed usage, if user/pass passed via CLI but mode needed, we might still ask.
        # But let's assume if CLI args led us here, we settle for standard unless prompted.
        if not args.user: # Interactive mode mostly
             mode = input("\nTipo de autenticação (1-Usuário Padrão, 2-Contrato, 3-Cartão Postagem) [1]: ")
             if mode == '2':
                 contract = input("Número do Contrato: ")
             elif mode == '3':
                 card = input("Número do Cartão de Postagem: ")

    token_data = generate_token(user, password, contract_number=contract, post_card=card)
    
    if token_data:
        # 3. Save
        if args.save:
            save_token_to_file(token_data)
        elif not args.user: # Only ask in interactive mode
            save = input("\nDeseja salvar este token em .credentials/correios_api_tokens.env? (S/n): ").lower()
            if save != 'n':
                 save_token_to_file(token_data)

if __name__ == "__main__":
    main()
